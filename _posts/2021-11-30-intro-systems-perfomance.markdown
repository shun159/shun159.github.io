---
layout: post
title:  "詳解システムパフォーマンス 1: Introduction"
date:   2021-11-30 17:39:58 +0900
categories:
  - Linux
  - Systems Performance: Enter and the Cloud
---
これの第一章，イントロダクションです．\\
<img src="https://www.oreilly.co.jp/books/images/picture_large978-4-87311-790-4.jpeg" width="60%">

## 1. システムパフォーマンス
システムパフォーマンスは，データパスに含まれるものであればすべて対象に含まれる．更に分散システムにおいては複数のサーバやアプリケーションが含まれる．\\
環境のデータパスや全体の構図を把握するために，ダイアグラムを見つけてくるか，必要であれば自分で作成する必要がある．

## 2. 職種
システムパフォーマンス関連の作業は，システム管理者，サポートスタッフ，アプリケーションデベロッパー，データベース管理者など…それぞれの領分において特化した分析を行う．\\
これらの職種の人々にとって，パフォーマンス関連の作業は担当業務の一部であり担当分野の中でパフォーマンスを向上させることを考えがちである．しかし，パフォーマンス障害によっては根本原因を見つけるためにこれらすべてのチームの協力が必要になる場合がある．

## 3. 作業
パフォーマンス分野の作業を理想的な遂行順に並べると，以下の通りとなる．
  1. パフォーマンスの目標を設定し，モデル化する
  2. プロトタイプソフトウェア，ハードウェアからパフォーマンス特性を掴む
  3. インテグレーション前の開発済みコードのパフォーマンス分析を行う
  4. ビルドされたソフトウェア，プレリリース，ポストリリースのソフトウェアの非回帰テストを行う
  5. リリースされたソフトウェアのベンチマーク・ベンチマーケティングを行う
  6. ターゲット環境で概念実証試験を行う
  7. 本番環境で構成を最適化する
  8. 本番稼働されているソフトウエアをモニタリングする
  9. パフォーマンス問題を分析する

パフォーマンスエンジニアリングは，ハードウェアを選択したりソフトウェアを書いたりする前に行うのが理想的である．\\
第１ステップだけでも良いが，製品はこのステップを省略して開発され，パフォーマンスエンジニアリングの作業は問題が発生するまで先送りされることが多い．しかし，開発プロセスが先に進めば進むほど，前の段階でのアーキテクチャに関する決定のためにパフォーマンス問題の修復は難しくなる．

また，これらの作業が全て行われることはあまりない．環境や作業，企業ごと，製品ごとに異なる．

## 4. 視点

パフォーマンスエンジニアの仕事には，様々な視点がある．以下の図にはワークロード分析とリソース分析がある．\\
これら２つは異なる向きからソフトウエアスタックにアプローチする

```
                          workload
                             |
                             v
               +--------------------------+
               |       application        | ------  Workload analysis
               +--------------------------+         -----------------
                    |             |                   ||
                    |             v                   ||      AA
          ---       |     +-----------------+         ||      ||
           |        |     |  system library |         ||      ||
           |        |     +-----------------+         ||      ||
operating  |        |             |                   ||      ||
system     |        v             v                   ||      ||
software   |   +--------------------------+           ||      ||
stack      |   |       application        |           ||      ||
           |   +--------------------------+           ||      ||
           |                |                         ||      ||
           |                v                         ||      ||
           |   +--------------------------+           ||      ||
           |   |         kernel           |           ||      ||
           |   +--------------------------+           VV      ||
          ---               |                                 ||
                            v                                 ||
               +--------------------------+                   ||
               |         device           | ------ Resource analysis
               +--------------------------+        -----------------
                
```

- ワークロード分析: ワークロード処理のパフォーマンスに責任を持つアプリケーションデベロッパー
- リソース分析: システムリソースを担当するシステム管理者が行うことが一般

## 5. 面白さと難しさ

1. 主観的
例えば，「ディスクIOの平均的な応答時間は1msである」について考えてみたとき，これは「良い」か「悪い」かはアプリケーションデベロッパとエンドユーザの期待値によって異なる．目標の平均応答時間を設定したり，要求の一定割合が特定の範囲のレイテンシで処理されることを必須としたりして，明確な目標を定義すれば，客観的なものとすることができる

2. 複雑性
上記のような主観性に加え，システムが複雑で分析を始める明確なポイントがないことによっても難しくなっている．分析は，ネットワークが悪いなどの決めつけなど，推測から始めることがあり，そうするとアナリストはその出発点が正しいかどうかから明らかにしなければならない\\
エラーを起こした他のコンポーネントが他のコンポーネントのパフォーマンス問題の原因になっているなどの \__エラーの連鎖(cascading faliure)__\ によって起きる問題もある．コンポーネントの間の込み入った関係を解きほぐし，問題にどう関わっているか理解しなければならない．

また，ボトルネックも複雑になっていて，予想外の形で連関している場合がある．一つのボトルネックを解決してもシステムの別の箇所にボトルネックが移るだけで期待されたほどパフォーマンスが改善しない場合もある．（よくある話）\\
システムが複雑でなくとも，本番環境のワークロードが持つ複雑な特性のためにパフォーマンス問題が起きる場合がある．そのような場合は，試験環境などでは再現しなかったりする．(これもよくある話)

つまり，局所最適化を避け，全体的なアプローチを取る．システムの内部でのやり取りと外部とのやり取りの両方，システム全体を調査しなければならない，ということである．

3. 複数のパフォーマンス問題
複雑なソフトウエアでは，同時に複数の問題が起きていることがよくある．問題の本質や更に重大な意味を持つ問題を見つけるために，問題の大きさを定量化する．可能なら解決したときのスピードアップの度合いも予測したい．この情報がエンジニアリングやオペレーションに投資する理由となる．

## 6. レイテンシ
待つために使った時間を計測した情報である．アプリケーションへの要求，データベースへのクエリ，ファイルシステムのオペレーションなど，あらゆる処理が完了するまでにかかった時間を指す．レイテンシがわかれば，スピードアップの上限がどれだけになるかが予測できる．例えば，100msかかるクエリがあった場合，そのうち80msがディスク読み出しにかかっていたと仮定した場合，キャッシュを使って高速化できる上限は５倍までと計算できる．これは予測されるスピードアップだが，この計算はパフォーマンス問題も定量化しているのである（つまり，ディスク読み出しが原因で5倍遅くなっている）

平均的なレイテンシしかわからない場所や，レイテンシーが全くわからない場所もある．BPFベースの可観測ツールによって，任意の箇所から計測できるようになり，レイテンシーの分散度合いを見ることができるようになった．

## 7. 可観測性
可観測性とは観察を通じてシステムを理解することを意味し，これを実現するツールを分類する．このツールには，カウンタ，プロファイリング，トレーシングを用いるツールが含む．システムの状態を変更するようなベンチマークツールは含まない．

### 1. カウンタ，統計，メトリック
アプリケーションとKernelは通常，その状態とアクティビティに関するデータ(操作カウント，バイトカウント，レイテンシ測定，エラー率)を提供します．一部は累積的に常にインクリメントする\\
累積カウンタは統計を計算するためのツール(変化率，平均，パーセンタイルなど)によって様々な時点で読み取る．メトリックは評価したりターゲットを監視するために選択された統計．

| # | Layer                     | Instrument | Example         |
|---|---------------------------|------------|-----------------|
| 1 | Applications/Kernel       | Counters   | /proc           |
| 2 | Performance Tools/Agants  | Statistics | vmstat,collectd |
| 3 | Performance Monitring UIs | Metrics    | graphana        |
| 4 | Event Processing          | Alerts     | prometheus      |

パフォーマンス統計の解釈は，それらがどのように計算されるかを理解することで向上する．\\
場合によっては，パフォーマンスの問題を解決するために時系列メトリックだけが必要になる場合があります．\\
問題が発生した時刻を知ることは，ソフトウェアや設定が変更された時刻と相関している可能性があり，もとに戻すことができます．また，CPUまたはディスクに問題があることを示唆している場合もありますが，より掘り下げて原因を見つけるにはプロファイリングツールが必要です．

### 2. プロファイリング
システムパフォーマンスにおいて，プロファイリングとはサンプリングを実行するツールの利用を意味します．測定のサンプルを取得して，ターゲットの荒いイメージを描画します．CPUは一般的なプロファイリングターゲットです．\\
CPUプロファイルはフレームグラフを用いると効果的に視覚化できます．CPUフレームグラフは多くのパフォーマンスの向上を見つけるのに役立ちます．

### 3. トレーシング
トレースはイベントベースの記録であり，イベントデータがキャプチャされて保存され，後で分析したり，カスタムサマリーやその他のアクションのためにon-the-flyで用いる．システムコール及びネットワークパケット用の特別な目的のトレースツールがあります．すべてのソフトウエア及び，ハードウェアイベントの実行を分析できる汎用トレースツールなど…これらを見通すトレーサは様々なイベントソース，特に静的・動的な計測，及びプログラマビリティのためにBPFを使用します．

## 8. Experimentation
これは，ベンチマークツールを指します．システムに合成ワークロードを適用し，そのパフォーマンスを測定して実行を行います．

## 9. クラウドコンピューティング
コンピューティングリソースをオンデマンドに展開する方法です．インスタンスと呼ばれる小さなシステムへの展開をサポートすることにより，アプリケーションの迅速なスケーリングが可能性なった．\\
これにより，クラウドからすぐに容量を追加できるため，厳密なキャパシティプランニングの必要性が減少したが，必要なリソースが少なくなればシステムを小さくできるため，パフォーマンス分析の要望は高まります．\\
クラウドコンピューティングと仮想化によって引き起こされる新たな問題は，他のテナントからのパフォーマンス効果の管理や，核テナントからの物理システムの可観測性が含まれます．例えば，システムによって適切に管理されていない限り，ディスクIOのパフォーマンスはネイバーとの競合のためにてかする可能性があります．

## 10. 方法論

システムパフォーマンスにおいて，様々なタスクを実行するための推奨手順を文書化する方法です．これは，ランダムなアプローチを行うことにより重要なものを見落とすことを防ぐためです．

### 1. Linuxのパフォーマンス分析

Linuxのツールを用いた60秒間で行えるパフォーマンスチェックリストです．

| #  | Tools             | Check                                                                                         |
|----|-------------------|-----------------------------------------------------------------------------------------------|
| 1  | uptime            | Load average                                                                                  |
| 2  | dmesg -T          | Kernel Errors                                                                                 |
| 3  | vmstat -SM 1      | system wide stat: run queue len, swapping, overall CPU usage                                  |
| 4  | mpstat -P ALL 1   | Per-CPU balance: a single busy CPU can indicate poor thread scaling                           |
| 5  | pidstat 1         | Per-Process CPU usage: identify unexpected CPU consumeers, and u/sy CPU time for each process |
| 6  | iostat -sxz       | Disk IO: IOPS and throughput, average wait time, percent busy                                 |
| 7  | free -m           | memory usage including the filesystem cache                                                   |
| 8  | sar -n DEV 1      | network device IO: packets and throughput                                                     |
| 9  | sar -n TCP,ETCP 1 | TCP stat: connection rates, retransmits                                                       |
| 10 | top               | check overview                                                                                              |


## 11. Case Studies

リアルなシチュエーションを例に上げていて，初めてみる内容として非常に良問．今日は時間がないのでここまで．





かしこ
